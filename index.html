// === 設定パラメータ ===
    const INTERVAL_SLOW = 4000; // 最も遅い間隔
    const INTERVAL_FAST = 450;  // 最も速い間隔
    const NOTE_SPEED = 6;       // ノーツ速度
    const HIT_X = 60;           // 判定ラインX

    // === 変数 ===
    const video = document.getElementById('mainVideo');
    const notesCanvas = document.getElementById('notes-canvas');
    const specCanvas = document.getElementById('spectrum-canvas');
    const nCtx = notesCanvas.getContext('2d');
    const sCtx = specCanvas.getContext('2d');
    
    const bpmDisplay = document.getElementById('bpm-display');
    const bpmSub = document.getElementById('bpm-sub');
    const heatBar = document.getElementById('heat-bar');
    const initScreen = document.getElementById('init-screen');

    let playlist = [];
    let audioCtx, analyser;
    let notes = [];
    let cruiseTimer = null;
    let nextNoteTime = 0;
    
    // ★新ロジック用変数
    let currentHeat = 0;      // 表示上のレベル (0.0~1.0)
    let avgEnergy = 0;        // 直近の平均音量
    let peakEnergy = 100;     // 直近の最大音量（正規化用）

    // === イベント設定 ===
    document.getElementById('mainFileInput').addEventListener('change', handleFileSelect);
    document.getElementById('subFileInput').addEventListener('change', handleFileSelect);
    
    // ダブルタップ全画面
    let lastTap = 0;
    document.getElementById('video-stage').addEventListener('click', () => {
        const now = new Date().getTime();
        if (now - lastTap < 300) {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
            else if (document.exitFullscreen) document.exitFullscreen();
        }
        lastTap = now;
    });

    function handleFileSelect(e) {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;
        playlist = playlist.concat(files);
        shuffleArray(playlist);
        initAudio(); 
        if (initScreen.style.display !== 'none') {
            initScreen.style.display = 'none';
            playNext();
            requestAnimationFrame(renderLoop);
        }
    }

    function initAudio() {
        if(audioCtx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.8; 
        const source = audioCtx.createMediaElementSource(video);
        source.connect(analyser);
        analyser.connect(audioCtx.destination);
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function playNext() {
        if(playlist.length === 0) return;
        if(cruiseTimer) clearTimeout(cruiseTimer);
        const file = playlist.shift();
        playlist.push(file);

        video.src = URL.createObjectURL(file);
        video.play().catch(()=>{});
        
        // 動画変更時リセット
        video.onloadedmetadata = () => { 
            video.currentTime = video.duration * (0.3 + Math.random() * 0.4); 
            // 平均値をリセットして新しい動画に馴染ませる
            avgEnergy = 0; 
            peakEnergy = 100;
        };
        
        const duration = (180 + Math.random() * 120) * 1000;
        cruiseTimer = setTimeout(playNext, duration);
    }
    
    function manualSkip() { playNext(); }

    // === メインループ ===
    function renderLoop() {
        requestAnimationFrame(renderLoop);
        if(!analyser) return;

        syncCanvas(notesCanvas);
        syncCanvas(specCanvas);

        // 1. オーディオ解析
        const bufferLen = analyser.frequencyBinCount;
        const data = new Uint8Array(bufferLen);
        analyser.getByteFrequencyData(data);
        drawSpectrum(data, bufferLen);

        // エネルギー計算 (低音〜中音重視)
        let rawEnergy = 0;
        const range = Math.floor(bufferLen * 0.5);
        for(let i=0; i<range; i++) rawEnergy += data[i];
        rawEnergy = rawEnergy / range; // 0〜255

        // ★新ロジック: 相対評価システム★
        
        // 平均音量の更新 (ゆっくり追従)
        if (rawEnergy > 0) {
            if (avgEnergy === 0) avgEnergy = rawEnergy;
            else avgEnergy = avgEnergy * 0.98 + rawEnergy * 0.02;
        }

        // ピーク音量の更新 (ゆっくり下がる)
        if (rawEnergy > peakEnergy) peakEnergy = rawEnergy;
        else peakEnergy -= 0.1;
        if (peakEnergy < 50) peakEnergy = 50; // 最低保証

        // 「今の音が平均よりどれだけ大きいか」を計算
        // 平均と同じなら delta = 0, 平均の1.5倍なら delta = 高い
        let delta = rawEnergy - avgEnergy;
        
        // 正規化 (-20 〜 +50 くらいの幅を 0.0〜1.0にするイメージ)
        // avgEnergyが高くても、deltaが小さければHeatは上がらない
        let targetHeat = 0;
        
        if (delta > 5) {
            // 平均より明確に大きい時だけヒートアップ
            targetHeat = delta / (peakEnergy * 0.4); // ピークの4割くらいの変動幅があればMAX
        } else {
            // 平均以下ならクールダウン
            targetHeat = 0;
        }
        
        // クランプ
        if(targetHeat > 1.0) targetHeat = 1.0;
        if(targetHeat < 0) targetHeat = 0;

        // 慣性をつけて currentHeat を targetHeat に近づける
        // 上がるのは早く、下がるのはゆっくり
        if (targetHeat > currentHeat) {
            currentHeat = currentHeat * 0.9 + targetHeat * 0.1;
        } else {
            currentHeat = currentHeat * 0.98 + targetHeat * 0.02;
        }

        // ヒートバー更新
        heatBar.style.width = (currentHeat * 100) + "%";
        
        // ヒート値からインターバル計算
        const currentInterval = INTERVAL_SLOW - (currentHeat * (INTERVAL_SLOW - INTERVAL_FAST));

        // 表示更新
        const percent = Math.round(currentHeat * 100);
        bpmDisplay.innerText = `Lv.${percent}`;
        bpmSub.innerText = `${(currentInterval/1000).toFixed(2)}s`;
        
        const hue = 180 + (currentHeat * 180);
        bpmDisplay.style.color = `hsl(${hue}, 100%, 60%)`;
        heatBar.style.background = `hsl(${hue}, 100%, 60%)`;

        // ノーツ生成
        const now = Date.now();
        if (now > nextNoteTime) {
            spawnNote(currentHeat, hue);
            nextNoteTime = now + currentInterval;
        }

        drawNotes();
    }

    function syncCanvas(cvs) {
        const p = cvs.parentElement;
        if (cvs.width !== p.clientWidth || cvs.height !== p.clientHeight) {
            cvs.width = p.clientWidth;
            cvs.height = p.clientHeight;
        }
    }

    function drawSpectrum(data, bufferLen) {
        const W = specCanvas.width; const H = specCanvas.height;
        sCtx.clearRect(0, 0, W, H);
        const barW = (W / bufferLen) * 2.5;
        let x = 0;
        for(let i = 0; i < bufferLen; i++) {
            const barH = (data[i] / 255) * H;
            const hue = (i / bufferLen) * 360;
            sCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            sCtx.fillRect(x, H - barH, barW, barH);
            x += barW + 1;
            if(x > W) break;
        }
    }

    function spawnNote(heat, hue) {
        const H = notesCanvas.height;
        let height = H * (0.3 + (heat * 0.6)); 
        notes.push({
            x: notesCanvas.width + 50,
            y: (H - height) / 2,
            width: 20,
            height: height,
            color: `hsl(${hue}, 100%, 60%)`,
            glow: heat * 20
        });
    }

    function drawNotes() {
        const W = notesCanvas.width; const H = notesCanvas.height;
        nCtx.clearRect(0, 0, W, H);
        const line = document.getElementById('hit-line');

        for (let i = notes.length - 1; i >= 0; i--) {
            const n = notes[i];
            n.x -= NOTE_SPEED;

            nCtx.shadowBlur = 10 + n.glow;
            nCtx.shadowColor = n.color;
            nCtx.fillStyle = n.color;
            nCtx.globalAlpha = 0.9;
            nCtx.beginPath();
            nCtx.roundRect(n.x, n.y, n.width, n.height, 4);
            nCtx.fill();

            if (n.x < HIT_X && n.x > HIT_X - NOTE_SPEED - 5) {
                line.style.background = n.color;
                line.style.boxShadow = `0 0 30px ${n.color}`;
                setTimeout(() => {
                    line.style.background = 'rgba(255,255,255,0.6)';
                    line.style.boxShadow = '0 0 15px #fff';
                }, 100);
            }
            if (n.x < -50) notes.splice(i, 1);
        }
        nCtx.shadowBlur = 0;
    }
